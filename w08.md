---
permalink: /W08/
---
[HOME](../)<br>
[<< PREVIOUS |](../W07/)<br>

# Top 10 List of Week 08

1. **[What is CPU Scheduling?](https://www.guru99.com/cpu-scheduling-algorithms.html)** <br>
**CPU Scheduling** is a process of determining which process will own CPU for execution while another process is on hold. The main task of CPU scheduling is to make sure that whenever the CPU remains idle, the OS at least select one of the processes available in the ready queue for execution. The selection process will be carried out by the CPU scheduler. It selects one of the processes in memory that are ready for execution. <br>
* * *

2. **[Preemptive vs Non-Preemptive Scheduling](https://www.geeksforgeeks.org/preemptive-and-non-preemptive-scheduling/)** <br>
In **Preemptive Scheduling**, the tasks are mostly assigned with their priorities. In **Non-preemptive Scheduling**, the CPU has been allocated to a specific process. To determine if scheduling is preemptive or non-preemptive, consider these four parameters: 1) **A process switches from the running to the waiting state**; 2) **Specific process switches from the running state to the ready state**; 3) **Specific process switches from the waiting state to the ready state**; 4) **Process finished its execution and terminated**. If only conditions 1 and 4 apply, the scheduling is called non-preemptive. All other scheduling are preemptive.<br>
* * *

3. **[Scheduling Algorithms](https://www.javatpoint.com/os-scheduling-algorithms)** <br>
There are various algorithms which are used by the Operating System to schedule the processes on the processor in an efficient way. The purpose of a scheduling algorithm is to get: Maximum CPU utilization, Fare allocation of CPU, Maximum throughput, Minimum turnaround time, Minimum waiting time, and Minimum response time. There are mainly six types of process scheduling algorithms: **First Come First Serve (FCFS)**, **Shortest-Job-First (SJF) Scheduling**, **Shortest Remaining Time**, **Priority Scheduling**, **Round Robin Scheduling**, and **Multilevel Queue Scheduling**. <br>
* * *

4. **[Peterson’s Algorithm in Process Synchronization](https://www.geeksforgeeks.org/petersons-algorithm-in-process-synchronization/)** <br>
The producer consumer problem (or bounded buffer problem) describes two processes, the producer and the consumer, which share a common, fixed-size buffer used as a queue. Producer produce an item and put it into buffer. If buffer is already full then producer will have to wait for an empty block in buffer. Consumer consume an item from buffer. If buffer is already empty then consumer will have to wait for an item in buffer. Implement Peterson’s Algorithm for the two processes using shared memory such that there is mutual exclusion between them. The solution should have free from synchronization problems. <br>
* * *

5. **[What is Semaphore?](https://www.guru99.com/semaphore-in-operating-system.html)** <br>
Semaphore is defined as a variable that is non-negative and shared between threads. It is a mechanism that can be used to provide synchronization of tasks. Counting semaphore uses a count that helps task to be acquired or released numerous times. The binary semaphores are quite similar to counting semaphores, but their value is restricted to 0 and 1. Wait operation helps you to control the entry of a task into the critical section Signal semaphore operation is used to control the exit of a task from a critical section. Semaphore allows more than one thread to access the critical section. One of the biggest limitations of a semaphore is priority inversion.<br>
* * *

6. **[Mutex vs Semaphore: What's the Difference?](https://techdifferences.com/difference-between-semaphore-and-mutex.html)** <br>
The basic difference between semaphore and mutex is that semaphore is a signalling mechanism i.e. processes perform wait() and signal() operation to indicate whether they are acquiring or releasing the resource, while Mutex is locking mechanism, the process has to acquire the lock on mutex object if it wants to acquire the resource. Semaphore is a better option in case there are multiple instances of resources available. In the case of single shared resource mutex is a better choice. <br>
* * *

7. **[What is a Deadlock?](https://www.guru99.com/deadlock-in-operating-system.html)** <br>
Deadlock Definition: It is a situation that occurs in OS when any process enters a waiting state because another waiting process is holding the demanded resource. A deadlock occurrence can be detected by the resource scheduler. It's important to prevent a deadlock before it can occur. A resource can be released only voluntarily by the process holding it after that process has finished its task. Hold and wait is a condition where processes must be stopped from holding single or multiple resources while simultaneously waiting for one or more others. Deadlock avoidance is the simplest and most useful model that each process declares the maximum number of resources of each type that it may need. <br>
* * *

8. **[Deadlock vs Starvation: What's the Difference?](https://techdifferences.com/difference-between-deadlock-and-starvation-in-os.html)** <br>
Deadlock and Starvation both are the conditions where the processes requesting for a resource has been delayed for a long. Although deadlock and starvation both are different from each other in many aspects. Deadlock is a condition where no process proceeds for execution, and each waits for resources that have been acquired by the other processes. On the other hands, in Starvation, process with high priorities continuously uses the resources preventing low priority process to acquire the resources. Both Deadlock and Starvation delays the process execution by blocking it. On one hand where deadlock can cause processes to starve, and on the other hands starvation can get the processes out of the deadlock. <br>
* * *

9. **[Banker's Algorithm in Operating System](https://www.guru99.com/bankers-algorithm-in-operating-system.html)** <br>
Banker's algorithm is used majorly in the banking system to avoid deadlock. It helps you to identify whether a loan will be given or not. Notations used in banker's algorithms are 1) **Available** 2) **Max** 3) **Allocation** 4) **Need**. Resource request algorithm enables you to represent the system behavior when a specific process makes a resource request. Banker's algorithm keeps many resources that satisfy the requirement of at least one client. The biggest drawback of banker's algorithm this that it does not allow the process to change its Maximum need while processing. <br>
* * *

10. **[Message Passing Model of Process Communication](https://www.tutorialspoint.com/message-passing-model-of-process-communication#:~:text=Message%20passing%20model%20allows%20multiple,used%20by%20most%20operating%20systems.)** <br>
Process communication is the mechanism provided by the operating system that allows processes to communicate with each other. This communication could involve a process letting another process know that some event has occurred or transferring of data from one process to another. One of the models of process communication is the message passing model. Message passing model allows multiple processes to read and write data to the message queue without being connected to each other. Messages are stored on the queue until their recipient retrieves them. Message queues are quite useful for interprocess communication and are used by most operating systems. <br>
* * *
